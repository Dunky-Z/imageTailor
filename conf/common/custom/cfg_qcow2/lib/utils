#!/bin/bash

# 创建一个工作区目录
function create_workspace() {
    # 创建一个临时目录作为工作区,XXXXXXXX会自动用随机字符替代
    WORKSPACE_DIR=$(mktemp -t -d --tmpdir=${TMP_DIR:-/tmp} hmi_build.XXXXXXXX)
    # 如果创建失败，返回错误
    if [[ $? != 0 ]];then
      echo "create workspace failed"
      return 1
    fi

    # 导出工作区目录的路径为环境变量
    export WORKSPACE_DIR
    export MOUNT_WORKSPACE_DIR=${WORKSPACE_DIR}/mnt
    export HOOKS_WORKSPACE_DIR=${WORKSPACE_DIR}/hooks
}

# 将钩子脚本复制到工作区
function copy_hooks2workspace() {
    # 如果钩子工作区目录不存在，则创建它
    [[ -d ${HOOKS_WORKSPACE_DIR} ]] || mkdir -p ${HOOKS_WORKSPACE_DIR}
    # 复制所有钩子脚本到钩子工作区目录
    cp -a $_PREFIX/hooks/* ${HOOKS_WORKSPACE_DIR}/
}

# 删除环境 
function remove_env() {
    # 如果挂载的工作区目录存在，则删除它
    if [[ -f ${MOUNT_WORKSPACE_DIR} ]]; then
        rm -rf ${MOUNT_WORKSPACE_DIR}
    fi
    # 删除整个工作区目录，确保文件系统安全
    rm -rf --one-file-system ${WORKSPACE_DIR}
    # 卸载所有循环设备
    losetup -D
}

# 检查是否需要进入调试模式
function check_break () {
    if echo "${break:-}" | egrep -e "(,|^)$1(,|$)" -q; then
        echo "Starting debug shell. Exit to resume building." >&2
        echo At stage $1 >&2
        shift
        "$@"
        echo "Resuming" >&2
    fi
}

# 运行钩子脚本
function run_hook () {
    # 复制钩子脚本到工作区
    copy_hooks2workspace
    # 检查是否需要在运行前进入调试模式
    check_break before-$1 ${break_cmd:-bash}
    # 如果钩子目录存在，则运行钩子脚本
    if [[ -d ${HOOKS_WORKSPACE_DIR}/$1.d ]]; then
        if [[ -n "$2" ]]; then
            # 如果提供了日志文件路径，则将输出重定向到该日志文件
            sh ${SCRIPT_HOME}/source_files ${HOOKS_WORKSPACE_DIR}/$1.d | tee $2
            if [[ ${PIPESTATUS[0]} != 0 ]]; then
                return 1
            fi
        else
            sh ${SCRIPT_HOME}/source_files ${HOOKS_WORKSPACE_DIR}/$1.d
        fi
    fi
    # 检查是否需要在运行后进入调试模式
    check_break after-$1 bash
}

# 创建运行环境
function create_env() {
    # 创建挂载工作区目录
    mkdir -p ${MOUNT_WORKSPACE_DIR}
    # 运行 root 钩子脚本
    TARGET_ROOT=${MOUNT_WORKSPACE_DIR} run_hook root
    # 检查工作区目录是否成功创建
    if [[ -z "$(ls ${MOUNT_WORKSPACE_DIR} | grep -v '^lost+found\|tmp$')" ]]; then
        echo "create target_root failed."
        return 1
    fi
    # 如果 resolv.conf 存在，则备份它
    if [[ -L ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf ]] || [[ -f ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf ]] ; then
        sudo mv ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf.ORIG
    fi
    # 创建并配置新的 resolv.conf
    mkdir -p ${MOUNT_WORKSPACE_DIR}/etc/
    touch ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf
    chmod 777 ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf
    # 如果宿主机的 resolv.conf 存在，则复制它的内容
    if [[ -e /etc/resolv.conf ]]; then
        cat /etc/resolv.conf > ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf
    else
        # 否则，使用默认的 DNS 服务器
        echo nameserver 8.8.8.8 > ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf
    fi
    # 挂载必要的目录
    mount_dir
}

# 挂载必要的系统目录
function mount_dir() {
    mkdir -p ${MOUNT_WORKSPACE_DIR}/sys ${MOUNT_WORKSPACE_DIR}/dev/pts ${MOUNT_WORKSPACE_DIR}/proc
    mount -t proc none ${MOUNT_WORKSPACE_DIR}/sys
    mount --bind /dev ${MOUNT_WORKSPACE_DIR}/dev
    mount --bind /dev/pts ${MOUNT_WORKSPACE_DIR}/dev/pts
    mount -t sysfs none ${MOUNT_WORKSPACE_DIR}/proc
}

# 卸载目录
function unmount_dir() {
    local mount_dir="$1"

    # 如果目录不存在，则输出错误并返回
    if [[ ! -d ${mount_dir} ]]; then
        echo "dir ${mount_dir} is not exist"
        return 1
    fi

    # 获取实际挂载的目录路径
    local link_dir=$(readlink -e ${mount_dir})
    # 获取所有挂载在该目录下的文件系统并按逆序排序
    local local_mnts=$(awk '{print $2}' < /proc/mounts | grep "^${link_dir}" | sort -r)
    # 逐个卸载文件系统
    for local_mnt in ${local_mnts}
    do
       umount -fl ${local_mnt} || true
       echo "unmount ${local_mnt}"
    done
}

# 卸载挂载的工作区目录
function unmount_mnt() {
    sync
    unmount_dir "${WORKSPACE_DIR}/mnt/boot"
    unmount_dir "${WORKSPACE_DIR}/mnt"
}

# 精简文件系统
function fstrim_mnt() {
    sync
    # 释放未使用的块
    fstrim "${WORKSPACE_DIR}/mnt"
}

# 在根文件系统中运行命令
function run_in_root() {
    ORIG_HOME=$HOME
    cmd="$@"
    export HOME=/root
    sudo -E chroot ${MOUNT_WORKSPACE_DIR} env -u TMPDIR PATH="\$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" sh -c "$cmd"
    export HOME=${ORIG_HOME}
}

# 在根文件系统中运行钩子脚本
function run_hook_in_root() {
    copy_hooks2workspace
    hook_name=$1

    # 如果钩子目录存在，则运行钩子脚本
    if [[ -d ${HOOKS_WORKSPACE_DIR}/${hook_name}.d ]];then
        sudo mkdir -p ${MOUNT_WORKSPACE_DIR}/tmp/hooks/
        sudo mount --bind ${HOOKS_WORKSPACE_DIR} ${MOUNT_WORKSPACE_DIR}/tmp/hooks
        sudo mount -o remount,ro,bind ${HOOKS_WORKSPACE_DIR} ${MOUNT_WORKSPACE_DIR}/tmp/hooks
        check_break before-${hook_name} run_in_root bash
        trap "check_break after-error $in_target_arg ${break_cmd:-bash}" ERR
        cp ${SCRIPT_HOME}/source_files ${MOUNT_WORKSPACE_DIR}
        run_in_root sh source_files /tmp/hooks/${hook_name}.d
        trap - ERR
        check_break after-${hook_name} run_in_root bash
        sudo umount -f ${MOUNT_WORKSPACE_DIR}/tmp/hooks
        sudo rm -rf ${MOUNT_WORKSPACE_DIR}/tmp/hooks
    fi
}

# 移除工作区
function remove_workspace() {
    TARGET_ROOT=${MOUNT_WORKSPACE_DIR} run_hook cleanup
    # 处理 resolv.conf 文件
    if [[ -e ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf ]] && lsattr ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf | grep '^....i' >/dev/null ; then
        rm -rf ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf.ORIG
    else
        rm -f ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf
        if [[ -L ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf.ORIG ]] || [[ -f ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf.ORIG ]] ; then
            mv ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf.ORIG ${MOUNT_WORKSPACE_DIR}/etc/resolv.conf
        fi
    fi
    # 卸载并清理临时目录
    if [[ -d ${MOUNT_WORKSPACE_DIR}/tmp ]];then
        unmount_dir ${MOUNT_WORKSPACE_DIR}/tmp
    fi
    if [[ -d ${MOUNT_WORKSPACE_DIR}/tmp ]];then
        # -maxdepth 1 -mindepth 1 表示只删除 tmp 目录下的文件，不删除 tmp 目录本身
        # --one-file-system 防止跨文件系统删除，确保只在同一个文件系统上删除
        find ${MOUNT_WORKSPACE_DIR}/tmp -maxdepth 1 -mindepth 1 | xargs sudo rm -rf --one-file-system
    fi
}
